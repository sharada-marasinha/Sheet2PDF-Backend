const express = require('express');
const { google } = require('googleapis');
const { PDFDocument, rgb, StandardFonts } = require('pdf-lib');
const fs = require('fs');
const archiver = require('archiver');
const cors = require('cors');
const path = require('path');

const app = express();
const PORT = 5000;

app.use(cors());
app.use(express.json());

// Configure these paths
const LOGO_PATH = 'assets/iCET-logo.png'; // Path to your company logo
const TEMP_DIR = './tmp';
const FONT_SIZE = 12;
const LINE_HEIGHT = 20;
const MARGIN = 50;

// Google Auth
const auth = new google.auth.GoogleAuth({
    keyFile: 'credentials.json',
    scopes: ['https://www.googleapis.com/auth/spreadsheets.readonly'],
});

// Extract Sheet ID from URL
const getSheetIdFromUrl = (url) => {
    const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
    return match ? match[1] : null;
};

// Read data from Google Sheet
async function getSheetData(spreadsheetId) {
    const client = await auth.getClient();
    const sheets = google.sheets({ version: 'v4', auth: client });

    const res = await sheets.spreadsheets.values.get({
        spreadsheetId,
        range: 'Sheet1',
    });

    return res.data.values;
}

// Generate professional A4 PDF with logo
async function generatePdf(row, headers) {
    // Create a new PDF document
    const pdfDoc = await PDFDocument.create();
    const page = pdfDoc.addPage([595.28, 841.89]); // A4 dimensions in points

    // Load fonts
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    // Embed company logo
    let logoImage;
    try {
        const logoBytes = fs.readFileSync(LOGO_PATH);
        logoImage = await pdfDoc.embedPng(logoBytes);
        const logoDims = logoImage.scale(0.5); // Scale down the logo
        page.drawImage(logoImage, {
            x: MARGIN,
            y: page.getHeight() - MARGIN - logoDims.height,
            width: logoDims.width,
            height: logoDims.height,
        });
    } catch (err) {
        console.warn('Could not load company logo:', err.message);
    }

    // Add title
    page.drawText('STUDENT APPLICATION FORM', {
        x: MARGIN,
        y: page.getHeight() - MARGIN - (logoImage ? logoImage.height * 0.5 + 20 : 0),
        size: 18,
        font: fontBold,
        color: rgb(0, 0, 0.5),
    });

    // Draw form fields
    let currentY = page.getHeight() - MARGIN - (logoImage ? logoImage.height * 0.5 + 50 : 50);

    // Draw a line separator
    page.drawLine({
        start: { x: MARGIN, y: currentY },
        end: { x: page.getWidth() - MARGIN, y: currentY },
        thickness: 1,
        color: rgb(0.8, 0.8, 0.8),
    });

    currentY -= 30;

    // Add student information section header
    page.drawText('Student Information:', {
        x: MARGIN,
        y: currentY,
        size: FONT_SIZE + 2,
        font: fontBold,
    });
    currentY -= LINE_HEIGHT;

    // Add form fields with labels and values
    headers.forEach((header, i) => {
        if (currentY < MARGIN + 50) {
            // Add a new page if we're running out of space
            page.drawText('Continued on next page...', {
                x: MARGIN,
                y: MARGIN + 30,
                size: FONT_SIZE,
                font: font,
            });

            const newPage = pdfDoc.addPage([595.28, 841.89]);
            currentY = newPage.getHeight() - MARGIN;

            // You might want to copy some header elements to the new page
            // For simplicity, we'll just continue with the fields
            return;
        }

        // Draw field label
        page.drawText(`${header}:`, {
            x: MARGIN,
            y: currentY,
            size: FONT_SIZE,
            font: fontBold,
        });

        // Draw field value
        page.drawText(row[i] || 'N/A', {
            x: MARGIN + 150,
            y: currentY,
            size: FONT_SIZE,
            font: font,
        });

        currentY -= LINE_HEIGHT;
    });

    // Add footer
    page.drawText('Generated by Student Application System', {
        x: MARGIN,
        y: MARGIN,
        size: 10,
        font: font,
        color: rgb(0.5, 0.5, 0.5),
    });

    // Generate filename from NIC or create a unique one
    const nicIndex = headers.findIndex(h => h.toLowerCase() === 'nic');
    let nic = row[nicIndex] || `student-${Math.random().toString(36).substr(2, 5)}`;
    const safeNic = nic.replace(/[^\w\-]/g, '_'); // make filename safe

    const filename = `${safeNic}-application-form.pdf`;
    const filePath = path.join(TEMP_DIR, filename);
    const pdfBytes = await pdfDoc.save();

    // Ensure directory exists
    if (!fs.existsSync(TEMP_DIR)) {
        fs.mkdirSync(TEMP_DIR);
    }

    fs.writeFileSync(filePath, pdfBytes);
    return filename;
}

app.post('/preview-sheet', async (req, res) => {
    try {
        const { sheetUrl } = req.body;
        const spreadsheetId = getSheetIdFromUrl(sheetUrl);
        if (!spreadsheetId) return res.status(400).json({ error: 'Invalid Sheet URL' });

        const rows = await getSheetData(spreadsheetId);
        if (!rows || rows.length < 2) return res.status(400).json({ error: 'No data found in sheet' });

        const [headers, ...data] = rows;

        res.json({
            headers,
            students: data,
            count: data.length
        });
    } catch (err) {
        console.error('Error:', err);
        res.status(500).json({ error: 'Error fetching sheet data' });
    }
});

// Route to generate PDFs and send ZIP
app.post('/generate-pdfs', async (req, res) => {
    try {
        const { sheetUrl } = req.body;
        const spreadsheetId = getSheetIdFromUrl(sheetUrl);
        if (!spreadsheetId) return res.status(400).send('Invalid Sheet URL');

        const rows = await getSheetData(spreadsheetId);
        if (!rows || rows.length < 2) return res.status(400).send('No data found in sheet');

        const [headers, ...data] = rows;

        // Clear tmp folder
        if (fs.existsSync(TEMP_DIR)) {
            fs.rmSync(TEMP_DIR, { recursive: true, force: true });
        }
        fs.mkdirSync(TEMP_DIR);

        // Generate PDFs
        const generatedFiles = await Promise.all(
            data.map(row => generatePdf(row, headers))
        );

        // Create ZIP
        const zipPath = path.join(TEMP_DIR, 'student_forms.zip');
        const output = fs.createWriteStream(zipPath);
        const archive = archiver('zip', { zlib: { level: 9 } });

        output.on('close', () => {
            res.download(zipPath, () => {
                // Clean up after download completes
                setTimeout(() => {
                    fs.rmSync(TEMP_DIR, { recursive: true, force: true });
                }, 5000);
            });
        });

        archive.on('error', (err) => {
            throw err;
        });

        archive.pipe(output);

        generatedFiles.forEach(file => {
            archive.file(path.join(TEMP_DIR, file), { name: file });
        });

        await archive.finalize();
    } catch (err) {
        console.error('Error:', err);
        res.status(500).send('Error generating PDFs: ' + err.message);
    }
});

// Start server
app.listen(PORT, () => {
    console.log(`âœ… Server running at http://localhost:${PORT}`);
    // Ensure temp directory exists
    if (!fs.existsSync(TEMP_DIR)) {
        fs.mkdirSync(TEMP_DIR);
    }
});